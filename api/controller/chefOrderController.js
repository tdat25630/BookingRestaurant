const Order = require('../models/order');
const OrderItem = require('../models/orderItem');
const { broadcastEvent } = require('../websocket');

exports.getOrdersForChef = async (req, res) => {
  try {
    const { status, limit = 100, page = 1, date } = req.query;

    let dateFilter = {};
    if (date) {
      const selectedDate = new Date(date);
      const startOfDay = new Date(selectedDate.setHours(0, 0, 0, 0));
      const endOfDay = new Date(selectedDate.setHours(23, 59, 59, 999));

      dateFilter = {
        orderTime: { $gte: startOfDay, $lte: endOfDay }
      };
    }

    // Chef ch·ªâ c·∫ßn xem ƒë∆°n h√†ng pending v√† preparing
    const validStatuses = ['pending', 'preparing'];
    let statusFilter = validStatuses;

    if (status && validStatuses.includes(status)) {
      statusFilter = [status];
    }

    const skip = (page - 1) * limit;

    // L·∫•y orders v·ªõi populate session info V√Ä table info
    const orders = await Order.find({
      status: { $in: statusFilter },
      paymentStatus: 'unpaid',
      ...dateFilter
    })
      .populate({
        path: 'sessionId',
        populate: {
          path: 'table',
          model: 'Table'
        }
      })
      .sort({ orderTime: 1 }) // Chef th∆∞·ªùng xem ƒë∆°n c≈© tr∆∞·ªõc
      .limit(parseInt(limit))
      .skip(skip)
      .lean();

    // L·∫•y t·∫•t c·∫£ order items cho c√°c orders n√†y
    const orderIds = orders.map(order => order._id);
    const orderItems = await OrderItem.find({
      orderId: { $in: orderIds },
    })
      .populate({
        path: 'menuItemId',
        select: 'name category cookingTime image',
        populate: {
          path: 'category',
          select: 'name'
        }
      })
      .lean();

    // Group items theo orderId
    const itemMap = {};
    orderItems.forEach(item => {
      const key = item.orderId.toString();
      if (!itemMap[key]) itemMap[key] = [];
      itemMap[key].push(item);
    });

    // Combine orders v·ªõi items v√† apply smart merge
    const ordersWithItems = orders.map(order => {
      const items = itemMap[order._id.toString()] || [];
      const mergedItems = items; // üîß Use raw, unmerged items
      const waitingTime = Math.floor((new Date() - new Date(order.orderTime)) / (1000 * 60));

      return {
        ...order,
        items: mergedItems,
        originalItems: items,
        waitingTime,
        itemCount: mergedItems.length,
        originalItemCount: items.length,
        estimatedCookingTime: Math.max(...items.map(item => item.menuItemId?.cookingTime || 0))
      };
    });

    // ƒê·∫øm t·ªïng s·ªë orders
    const totalCount = await Order.countDocuments({
      status: { $in: statusFilter }
    });

    res.json({
      orders: ordersWithItems,
      totalCount,
      currentPage: parseInt(page),
      totalPages: Math.ceil(totalCount / limit),
      statusFilter
    });

  } catch (err) {
    console.error('‚ùå L·ªói l·∫•y danh s√°ch ƒë∆°n h√†ng cho Chef:', err);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ l·∫•y danh s√°ch ƒë∆°n h√†ng',
      details: err.message
    });
  }
};
// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng (Chef)
exports.updateOrderStatusByChef = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, estimatedTime } = req.body;

    // Validate status
    const validStatuses = ['pending', 'preparing', 'cooking', 'served'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: 'Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá',
        validStatuses
      });
    }

    const updateData = { status };

    // N·∫øu chuy·ªÉn sang preparing, c·∫≠p nh·∫≠t th·ªùi gian b·∫Øt ƒë·∫ßu n·∫•u
    if (status === 'preparing') {
      updateData.preparingStartTime = new Date();
      if (estimatedTime) {
        updateData.estimatedCompleteTime = new Date(Date.now() + estimatedTime * 60000);
      }
    }

    // N·∫øu chuy·ªÉn sang served, c·∫≠p nh·∫≠t th·ªùi gian ho√†n th√†nh
    if (status === 'served') {
      updateData.completedTime = new Date();
    }

    const updatedOrder = await Order.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    ).populate({
      path: 'sessionId',
      populate: {
        path: 'table',
        model: 'Table'
      }
    });

    broadcastEvent('orderCreated');

    if (!updatedOrder) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng' });
    }

    // C·∫≠p nh·∫≠t t·∫•t c·∫£ order items n·∫øu ƒë∆°n h√†ng served
    if (status === 'served') {
      await OrderItem.updateMany(
        { orderId: id },
        { status: 'done' }
      );
    }

    res.json({
      message: `ƒê√£ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh ${status}`,
      order: updatedOrder
    });

  } catch (err) {
    console.error('‚ùå L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng:', err);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng',
      details: err.message
    });
  }
};

exports.updateOrderItemStatusByChef = async (req, res) => {
  try {
    const { itemId } = req.params;
    const { status, itemIds } = req.body; // Th√™m itemIds cho merged items

    const validStatuses = ['ordered', 'cooking', 'preparing', 'done'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: 'Tr·∫°ng th√°i m√≥n ƒÉn kh√¥ng h·ª£p l·ªá',
        validStatuses
      });
    }

    // N·∫øu c√≥ itemIds (merged items), update multiple
    const idsToUpdate = itemIds && itemIds.length > 0 ? itemIds : [itemId];

    // Update t·∫•t c·∫£ items
    const updatePromises = idsToUpdate.map(id =>
      OrderItem.findByIdAndUpdate(
        id,
        { status },
        { new: true }
      ).populate('menuItemId', 'name category')
    );

    const updatedItems = await Promise.all(updatePromises);

    if (updatedItems.some(item => !item)) {
      return res.status(404).json({ error: 'Kh√¥ng t√¨m th·∫•y m√≥n ƒÉn' });
    }

    // L·∫•y orderId t·ª´ item ƒë·∫ßu ti√™n
    const orderId = updatedItems[0].orderId;

    // Ki·ªÉm tra xem t·∫•t c·∫£ items c·ªßa order ƒë√£ done ch∆∞a
    const allItems = await OrderItem.find({ orderId });
    const allDone = allItems.every(item => item.status === 'done');
    const hasPreparingItems = allItems.some(item => item.status === 'preparing');
    const allOrdered = allItems.every(item => item.status === 'ordered');

    let newOrderStatus = null;
    let updateOrderData = {};

    if (allDone) {
      newOrderStatus = 'served';
      updateOrderData = {
        status: 'served',
        completedTime: new Date()
      };
    } else if (hasPreparingItems && !allOrdered) {
      newOrderStatus = 'preparing';
      updateOrderData = {
        status: 'preparing',
        preparingStartTime: new Date()
      };
    } else if (allOrdered) {
      newOrderStatus = 'pending';
      updateOrderData = { status: 'pending' };
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i Order n·∫øu c·∫ßn
    if (newOrderStatus) {
      await Order.findByIdAndUpdate(orderId, updateOrderData);
    }

    broadcastEvent('orderCreated');

    res.json({
      message: `ƒê√£ c·∫≠p nh·∫≠t ${idsToUpdate.length} m√≥n ƒÉn th√†nh ${status}`,
      items: updatedItems,
      orderStatus: newOrderStatus,
      orderCompleted: allDone
    });

  } catch (err) {
    console.error('‚ùå L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i m√≥n ƒÉn:', err);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i m√≥n ƒÉn',
      details: err.message
    });
  }
};

// B·∫Øt ƒë·∫ßu n·∫•u t·∫•t c·∫£ m√≥n trong ƒë∆°n h√†ng - 
exports.startCookingOrder = async (req, res) => {
  try {
    const { id } = req.params;
    const { estimatedTime } = req.body;

    // L·∫•y t·∫•t c·∫£ items c·ªßa order
    const orderItems = await OrderItem.find({ orderId: id });
    const itemsToStart = orderItems.filter(item => item.status === 'ordered');

    if (itemsToStart.length === 0) {
      return res.status(400).json({
        error: 'Kh√¥ng c√≥ m√≥n n√†o c·∫ßn b·∫Øt ƒë·∫ßu n·∫•u'
      });
    }

    // C·∫≠p nh·∫≠t t·∫•t c·∫£ items th√†nh preparing
    await OrderItem.updateMany(
      { orderId: id, status: 'ordered' },
      { status: 'preparing' }
    );

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i order
    const updateData = {
      status: 'preparing',
      preparingStartTime: new Date()
    };

    if (estimatedTime) {
      updateData.estimatedCompleteTime = new Date(Date.now() + estimatedTime * 60000);
    }

    const updatedOrder = await Order.findByIdAndUpdate(
      id,
      updateData,
      { new: true }
    ).populate({
      path: 'sessionId',
      populate: {
        path: 'table',
        model: 'Table'
      }
    });

    res.json({
      message: `ƒê√£ b·∫Øt ƒë·∫ßu n·∫•u ${itemsToStart.length} m√≥n`,
      order: updatedOrder,
      itemsStarted: itemsToStart.length
    });

  } catch (err) {
    console.error('‚ùå L·ªói b·∫Øt ƒë·∫ßu n·∫•u ƒë∆°n h√†ng:', err);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu n·∫•u ƒë∆°n h√†ng',
      details: err.message
    });
  }
};

// L·∫•y th·ªëng k√™ cho Chef dashboard
exports.getChefDashboardStats = async (req, res) => {
  try {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const stats = await Promise.all([

      Order.countDocuments({
        status: 'pending'
      }),


      Order.countDocuments({
        status: 'preparing'
      }),

      // ƒê∆°n h√†ng ho√†n th√†nh h√¥m nay
      Order.countDocuments({
        status: 'served',
        completedTime: { $gte: today }
      }),

      // T·ªïng doanh thu h√¥m nay 
      Order.aggregate([
        {
          $match: {
            status: 'served',
            paymentStatus: 'paid',
            completedTime: { $gte: today }
          }
        },
        {
          $group: {
            _id: null,
            total: { $sum: '$totalAmount' }
          }
        }
      ])
    ]);

    res.json({
      pendingOrders: stats[0],
      preparingOrders: stats[1],
      completedToday: stats[2],
      revenueToday: stats[3][0]?.total || 0,
      timestamp: new Date()
    });

  } catch (err) {
    console.error('‚ùå L·ªói l·∫•y th·ªëng k√™ Chef:', err);
    res.status(500).json({
      error: 'Kh√¥ng th·ªÉ l·∫•y th·ªëng k√™',
      details: err.message
    });
  }
};

const smartMergeItems = (items) => {
  const grouped = {};

  items.forEach(item => {
    // Key = menuItemId + notes (normalize notes)
    const normalizedNotes = (item.notes || '').trim().toLowerCase();
    const key = `${item.menuItemId._id}__${normalizedNotes}`;

    if (grouped[key]) {
      // Merge c√πng m√≥n + c√πng notes
      grouped[key].quantity += item.quantity;
      grouped[key].totalPrice += item.price;
      grouped[key].itemIds.push(item._id);

      // ∆Øu ti√™n status cao nh·∫•t: done > preparing > ordered
      const statusPriority = { 'ordered': 1, 'preparing': 2, 'done': 3 };
      if (statusPriority[item.status] > statusPriority[grouped[key].status]) {
        grouped[key].status = item.status;
      }
    } else {
      // T·∫°o group m·ªõi
      grouped[key] = {
        ...item,
        quantity: item.quantity,
        totalPrice: item.price,
        itemIds: [item._id],
        displayKey: key
      };
    }
  });

  return Object.values(grouped);
};
